<!DOCTYPE html><html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>littledivy.com</title>
</head>
<style>
html, body {
  min-height: 100vh;
}

body {
  background-color: black;
  margin: 0;
  padding: 2rem;
  overflow-x: hidden;
  color: white;
  font: 2rem Inconsolata, monospace;
  text-shadow: 0 0 5px #C8C8C8;
  &::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: repeating-linear-gradient(
      0deg,
      rgba(black, 0.15),
      rgba(black, 0.15) 1px,
      transparent 1px,
      transparent 2px
    );
    pointer-events: none;
  }
}
::selection {
  background: #0080FF;
  text-shadow: none;
}
pre {
  margin: 0;
}

#input {
  display: inline;
  outline: none;
  visibility: visible;
  caret-color: transparent;
}

/*
  If you press the Insert key, the vertical line caret will automatically
  be replaced by a one-character selection.
*/
#input::selection {
  color: #000;
  background: #0F0;
}

#input:empty::before {
  content: ' ';
}

@keyframes blink {
  to {
    visibility: hidden;
  }
}

#input:focus + #caret {
  animation: blink 1s steps(5, start) infinite;
}

#input.noCaret + #caret {
  visibility: hidden;
}

#caret {
  border: 0;
  padding: 0;
  outline: none;
  background-color: #0F0;
  display: inline-block;
  font-family: monospace;
  font-size: 1.8rem;
}

@keyframes flicker {
  0% {
    opacity: 0.27861;
  }
  5% {
    opacity: 0.34769;
  }
  10% {
    opacity: 0.23604;
  }
  15% {
    opacity: 0.90626;
  }
  20% {
    opacity: 0.18128;
  }
  25% {
    opacity: 0.83891;
  }
  30% {
    opacity: 0.65583;
  }
  35% {
    opacity: 0.67807;
  }
  40% {
    opacity: 0.26559;
  }
  45% {
    opacity: 0.84693;
  }
  50% {
    opacity: 0.96019;
  }
  55% {
    opacity: 0.08594;
  }
  60% {
    opacity: 0.20313;
  }
  65% {
    opacity: 0.71988;
  }
  70% {
    opacity: 0.53455;
  }
  75% {
    opacity: 0.37288;
  }
  80% {
    opacity: 0.71428;
  }
  85% {
    opacity: 0.70419;
  }
  90% {
    opacity: 0.7003;
  }
  95% {
    opacity: 0.36108;
  }
  100% {
    opacity: 0.24387;
  }
}
@keyframes textShadow {
  0% {
    text-shadow: 0.4389924193300864px 0 1px rgba(0,30,255,0.5), -0.4389924193300864px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  5% {
    text-shadow: 2.7928974010788217px 0 1px rgba(0,30,255,0.5), -2.7928974010788217px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  10% {
    text-shadow: 0.02956275843481219px 0 1px rgba(0,30,255,0.5), -0.02956275843481219px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  15% {
    text-shadow: 0.40218538552878136px 0 1px rgba(0,30,255,0.5), -0.40218538552878136px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  20% {
    text-shadow: 3.4794037899852017px 0 1px rgba(0,30,255,0.5), -3.4794037899852017px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  25% {
    text-shadow: 1.6125630401149584px 0 1px rgba(0,30,255,0.5), -1.6125630401149584px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  30% {
    text-shadow: 0.7015590085143956px 0 1px rgba(0,30,255,0.5), -0.7015590085143956px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  35% {
    text-shadow: 3.896914047650351px 0 1px rgba(0,30,255,0.5), -3.896914047650351px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  40% {
    text-shadow: 3.870905614848819px 0 1px rgba(0,30,255,0.5), -3.870905614848819px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  45% {
    text-shadow: 2.231056963361899px 0 1px rgba(0,30,255,0.5), -2.231056963361899px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  50% {
    text-shadow: 0.08084290417898504px 0 1px rgba(0,30,255,0.5), -0.08084290417898504px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  55% {
    text-shadow: 2.3758461067427543px 0 1px rgba(0,30,255,0.5), -2.3758461067427543px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  60% {
    text-shadow: 2.202193051050636px 0 1px rgba(0,30,255,0.5), -2.202193051050636px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  65% {
    text-shadow: 2.8638780614874975px 0 1px rgba(0,30,255,0.5), -2.8638780614874975px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  70% {
    text-shadow: 0.48874025155497314px 0 1px rgba(0,30,255,0.5), -0.48874025155497314px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  75% {
    text-shadow: 1.8948491305757957px 0 1px rgba(0,30,255,0.5), -1.8948491305757957px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  80% {
    text-shadow: 0.0833037308038857px 0 1px rgba(0,30,255,0.5), -0.0833037308038857px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  85% {
    text-shadow: 0.09769827255241735px 0 1px rgba(0,30,255,0.5), -0.09769827255241735px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  90% {
    text-shadow: 3.443339761481782px 0 1px rgba(0,30,255,0.5), -3.443339761481782px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  95% {
    text-shadow: 2.1841838852799786px 0 1px rgba(0,30,255,0.5), -2.1841838852799786px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
  100% {
    text-shadow: 2.6208764473832513px 0 1px rgba(0,30,255,0.5), -2.6208764473832513px 0 1px rgba(255,0,80,0.3), 0 0 3px;
  }
}
.crt::after {
  content: " ";
  display: block;
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background: rgba(18, 16, 16, 0.1);
  opacity: 0;
  z-index: 2;
  pointer-events: none;
  animation: flicker 0.15s infinite;
}
.crt::before {
  content: " ";
  display: block;
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
  z-index: 2;
  background-size: 100% 2px, 3px 100%;
  pointer-events: none;
}
.crt {
  animation: textShadow 1.6s infinite;
}
#history {
	padding-top: 1rem;
}
p {
  font-size: 1.5rem;
  margin: 0;
  padding: 0;
}
a {
  color: #00FF00;
  text-decoration: none;
}
@media only screen and (min-width: 1200px) {
  .flex {
    display: flex;
    justify-content: space-evenly;
  }

  body {
    font-size: 1.8rem;
  }
}
.img-with-overlay {
  position: relative;
}
#media-meta {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.5);
  color: white;
  padding: 0.5rem;
  font-size: 1.5rem;
}
.selected-suggestion {
  background-color: #0080FF;
}
</style>
<body class="crt">
	<div class="flex">
		<div>

			<div style="margin-bottom: 1rem; padding-top: 1rem;">
				<pre>
Divy Srivastava (littledivy.com)

Software Engineer @ <a href="https://deno.com" target="_blank">Deno</a>

I like engines, compilers and 
cryptography.

<a href="https://github.com/littledivy" target="_blank">GitHub</a> | <a href="https://twitter.com/undefined_void" target="_blank">Twitter</a> | <a href="https://www.linkedin.com/in/divy-srivastava-032939150/" target="_blank">LinkedIn</a>

$ open $(random 1 10).jpg

</pre>

<div class="img-with-overlay">
<p id="media-meta"></p>
<img id="media" style="max-height: 400px; cursor: pointer;">
</div>

	</div>

		</div>
		<div>
	<div id="history">

	</div>
	$
	<div id="input" contenteditable="true"></div><button id="caret" for="input">&nbsp;</button>
	<div id="suggest"></div>
		</div>
	</div>
</body>
<script>
const history = document.getElementById('history');
const input = document.getElementById('input');
const cursor = document.getElementById('cursor');
const suggest = document.getElementById('suggest');
const media = document.getElementById('media');
const mediaMeta = document.getElementById('media-meta');

const random = (min, max, prev) => {
  const num = Math.floor(Math.random() * (max - min + 1)) + min;
  return num === prev ? random(min, max, prev) : num;
};
let img = random(1, 3);
media.src = `media/${img}.jpg`;
media.onclick = () => {
	img = random(1, 3, img);
	media.src = `media/${img}.jpg`;
	getMediaMeta();
};

async function getMediaMeta() {
	await fetch(`media/${img}.text`)
		.then(response => response.text())
		.then(text => {
		  const city = text.split('\n')[0];
		  const [latitude, longitude] = text.split('\n')[1].split(', ').map(s => Number(s.trim()));
		  return `<a href="https://www.google.com/maps/search/?api=1&query=${latitude},${longitude}" target="_blank">${city}</a>`;
		})
		.then(text => mediaMeta.innerHTML = text);
}

media.onload = getMediaMeta;

function focusAndMoveCursorToTheEnd(e) {
  input.focus();

  const range = document.createRange();
  const selection = window.getSelection();
  const { childNodes } = input;
  const lastChildNode = childNodes && childNodes.length - 1;

  range.selectNodeContents(lastChildNode === -1 ? input : childNodes[lastChildNode]);
  range.collapse(false);

  selection.removeAllRanges();
  selection.addRange(range);
}

function handleCommand(command) {
  const line = document.createElement('DIV');
	line.innerHTML = `$ ${command} <br> ${exec(command)}<br><br>`;
  history.appendChild(line);
}

const files = [
  { name: 'jsr-ios.html', date: 'Jul 2024' },
  { name: 'swiftui-ref.html', date: 'Jul 2024' },
  { name: 'turbocall.html', date: 'Mar 2024' },
  { name: 'turbocall.pdf', date: 'Mar 2024' },
];

function exec(command) {
  const [cmd, ...args] = command.split(' ');
  switch (cmd) {
    case 'open':{
      if (files.some(file => file.name === args[0])) {
	      setTimeout(() => window.open(args[0], '_blank'), 200);
	return `Opening ${args[0]}`;
      }
      return `File not found: ${args[0]}`;
    }
    case 'tree':
      let tree = '.';
	for (let i = 0; i < files.length; i++) {
	  let d = args[0] === '-D' ? `[${files[i].date}] `: ""
	  tree += `<br>`
  	  if (i === files.length - 1) {
		  tree += `└── ${d}<a href="/${files[i].name}">${files[i].name}</a>`;
   	  } else {
		  tree += `├── ${d}<a href="/${files[i].name}">${files[i].name}</a>`;
	  }
      }
      return tree;
    case 'ls':
      return files.map(file => file.name).join('<br>');
    case 'clear':
      history.innerHTML = '';
      return '';
    case 'journalctl':
      return 'systemd[1]: Starting littledivy.com...<br>systemd[1]: Started littledivy.com.';
    default:
      return `Unknown command: ${command}`
  }
}

handleCommand('journalctl -xe');
handleCommand('tree -D');

document.addEventListener('selectionchange', () => {
  if (document.activeElement.id !== 'input') return;

  const range = window.getSelection().getRangeAt(0);
  const start = range.startOffset;
  const end = range.endOffset;
  const length = input.textContent.length;

  if (end < length) {
    input.classList.add('noCaret');
  } else {
    input.classList.remove('noCaret');
  }
});

input.addEventListener('input', () => {
  if (input.childElementCount > 0) {
    const lines = input.innerText.replace(/\n$/, '').split('\n');
    const lastLine = lines[lines.length - 1];

    for (let i = 0; i <= lines.length - 2; ++i) {
      handleCommand(lines[i]);
    }

    input.textContent = lastLine;
    focusAndMoveCursorToTheEnd();
  }

  if (input.innerText.length === 0) {
    input.classList.remove('noCaret');
  }
});

document.addEventListener('keydown', (e) => {
  if (e.target !== input) focusAndMoveCursorToTheEnd();
});

let currentSuggestion = 0;
input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    if (suggest.innerHTML) {
      const node = document.getElementsByClassName('selected-suggestion')[0];
      if (node) {
	input.textContent = input.textContent.replace(/[^ ]+$/, node.textContent);
      }
    }

    handleCommand(input.textContent);
    input.textContent = '';
    suggest.innerHTML = '';
    focusAndMoveCursorToTheEnd();
  } else if (e.key === 'Tab') {
    e.preventDefault();
    if (suggest.innerHTML) {
      currentSuggestion++;
    }

    const [cmd, ...args] = input.textContent.split(' ');
    const suggestions = files
      .map(file => file.name)
      .filter(name => args[0] ? name.startsWith(args[0]) : true);

    suggest.innerHTML = suggestions
     .map((name, idx) => `<span class=${currentSuggestion % suggestions.length == idx ? "selected-suggestion" : ""}>${name}</span>`)
     .join('<br>');
  }

  if ((e.key === 'Backspace' || e.key === "Escape")
	  && suggest.innerHTML) {
    suggest.innerHTML = '';
  }
});

input.focus();
</script>
</html>
