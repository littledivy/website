<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Divy Srivastava" />
  <meta name="dcterms.date" content="2024-08-19" />
  <title>Deno 2 internals</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; } /* Alert */
    code span.an { color: #008000; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #0000ff; } /* ControlFlow */
    code span.ch { color: #008080; } /* Char */
    code span.cn { } /* Constant */
    code span.co { color: #008000; } /* Comment */
    code span.cv { color: #008000; } /* CommentVar */
    code span.do { color: #008000; } /* Documentation */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.im { } /* Import */
    code span.in { color: #008000; } /* Information */
    code span.kw { color: #0000ff; } /* Keyword */
    code span.op { } /* Operator */
    code span.ot { color: #ff4000; } /* Other */
    code span.pp { color: #ff4000; } /* Preprocessor */
    code span.sc { color: #008080; } /* SpecialChar */
    code span.ss { color: #008080; } /* SpecialString */
    code span.st { color: #008080; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #008080; } /* VerbatimString */
    code span.wa { color: #008000; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <script src='https://unpkg.com/panzoom@9.4.0/dist/panzoom.min.js'></script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Deno 2 internals</h1>
<p class="author">Divy Srivastava</p>
<p class="date">19 August 2024</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#description" id="toc-description">Description</a></li>
<li><a href="#deno-2.0" id="toc-deno-2.0">Deno 2.0</a></li>
<li><a href="#build-system" id="toc-build-system">Build system</a>
<ul>
<li><a href="#development-tips" id="toc-development-tips">Development
tips</a></li>
</ul></li>
<li><a href="#typescript" id="toc-typescript">TypeScript</a></li>
<li><a href="#v8-snapshots" id="toc-v8-snapshots">V8 Snapshots</a></li>
<li><a href="#external-references" id="toc-external-references">External
References</a></li>
<li><a href="#code-cache" id="toc-code-cache">Code cache</a></li>
<li><a href="#event-loop" id="toc-event-loop">Event loop</a>
<ul>
<li><a href="#jsruntimepoll_event_loop"
id="toc-jsruntimepoll_event_loop"><code>JsRuntime::poll_event_loop</code></a></li>
<li><a href="#spawn_blocking"
id="toc-spawn_blocking"><code>spawn_blocking</code></a></li>
</ul></li>
<li><a href="#ops" id="toc-ops">Ops</a></li>
<li><a href="#resources" id="toc-resources">Resources</a>
<ul>
<li><a href="#deno_coreresource"
id="toc-deno_coreresource"><code>deno_core::Resource</code></a></li>
<li><a href="#deno_coregarbagecollected"
id="toc-deno_coregarbagecollected"><code>deno_core::GarbageCollected</code></a></li>
<li><a href="#cppgc" id="toc-cppgc">Cppgc</a></li>
</ul></li>
<li><a href="#permissions" id="toc-permissions">Permissions</a></li>
<li><a href="#built-ins" id="toc-built-ins">Built-ins</a></li>
<li><a href="#node.js-compatibility"
id="toc-node.js-compatibility">Node.js compatibility</a>
<ul>
<li><a href="#node-api" id="toc-node-api">Node API</a></li>
<li><a href="#http" id="toc-http">HTTP</a></li>
<li><a href="#ffi" id="toc-ffi">FFI</a></li>
<li><a href="#websockets" id="toc-websockets">WebSockets</a></li>
</ul></li>
</ul>
</nav>
<h2 id="description">Description</h2>
<blockquote>
<p>Warning: Work in progress document.</p>
</blockquote>
<p>This document describes the internals of Deno 2. This is intended to
be a digestable doc for developers who are interested in contributing to
Deno or just people who want to understand how it works.</p>
<p>Deno is one of the largest open-source Rust projects with ~1k
contributors and 15 active contributors.</p>
<p>Disclaimer: This is a living document and may not be up-to-date.</p>
<h2 id="deno-2.0">Deno 2.0</h2>
<p>Deno 2 is set to release in October 2024. There have been many
deprecations and release candidates leading up to this release.</p>
<h2 id="build-system">Build system</h2>
<p>Deno uses the standard cargo build system. It has two executable
entrypoints in <code>cli/main.rs</code> and
<code>cli/mainrt.rs</code>.</p>
<p>Building is as simple as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone https://github.com/denoland/deno <span class="at">--recurse-submodules</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> deno</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> build</span></code></pre></div>
<p>A few cruical things happen during the build process:</p>
<ul>
<li>transpile TypeScript built-ins</li>
<li>code generation for async Rust ops</li>
<li>generate <a href="#v8-snapshots">V8 snapshots</a> for tsc and
built-ins</li>
<li>linking with prebuilt v8 and setting up node-api symbols</li>
</ul>
<h3 id="development-tips">Development tips</h3>
<ol type="1">
<li>Save linking time by building only the deno binary:</li>
</ol>
<pre><code>cargo build -p deno --bin deno</code></pre>
<ol start="2" type="1">
<li>Running unit tests without rebuilding:</li>
</ol>
<pre><code>target/debug/deno test -A --config tests/config/deno.json tests/unit/webcrypto_test.ts --filter &quot;rsa keygen&quot;</code></pre>
<ol start="3" type="1">
<li>Hot-reload for builtin JavaScript code:</li>
</ol>
<pre><code>cargo build -p deno --bin deno --features hmr</code></pre>
<p>You don’t have to rebuild Deno when making changes to the builtin
JS/TS source.</p>
<ol start="4" type="1">
<li>Hot-reload extension crates with <code>cargo-plonk</code>:</li>
</ol>
<pre><code>cargo install cargo-plonk</code></pre>
<p>TODO: cargo-plonk</p>
<h2 id="typescript">TypeScript</h2>
<p>Deno has several ways to handling TypeScript code depending on the
context. It uses swc for type-stripping and bundling and the TypeScript
compiler (tsc) for LSP &amp; type-checking.</p>
<p>tsc is written in JS and runs in a seperate V8 isolate with its own
custom snapshot. <a
href="https://github.com/denoland/deno/tree/0cb00a6e89d83d4e16e6616f7af8819bd894b0da/cli/tsc"><code>cli/tsc/</code></a>
contains the code for the tsc bindings.</p>
<p><code>00_typescript.js</code> is the bundled source of the official
TypeScript compiler. <code>01_main_compiler.js</code> is the entrypoint
for exeucting the compiler.</p>
<p>A seperate custom V8 snapshot is created during build time for these
sources.</p>
<p>TODO: swc emit</p>
<h2 id="v8-snapshots">V8 Snapshots</h2>
<p>Most Deno built-ins and Web APIs are written in JavaScript and
dispatch to Rust for the actual operation via the “op” system. Because
of this there is a lot of JavaScript that needs to executed before user
code runs. To avoid parsing and compiling this JavaScript on every
startup, Deno leverages V8 snapshots to preprocess these builtins into a
native format that can be quickly loaded into V8.</p>
<p>The build script is responsible for generating JavaScript snapshots
for built-ins and the TypeScript compiler.</p>
<table>
<thead>
<tr>
<th>Index</th>
<th>Context</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>VM_CONTEXT_INDEX</td>
</tr>
<tr>
<td>1</td>
<td>MAIN_CONTEXT</td>
</tr>
</tbody>
</table>
<h2 id="external-references">External References</h2>
<p>Native functions and objects allocated during snapshot</p>
<h2 id="code-cache">Code cache</h2>
<h2 id="event-loop">Event loop</h2>
<p>Deno uses Tokio for its event loop. Tokio is an asynchronous runtime
for Rust that provides I/O operations, task scheduling and
message-passing primitives. Deno uses a single-threaded Tokio runtime
but I/O tasks maybe also be spawned on a threadpool.</p>
<p>The event loop integrates with V8’s microtask queue to run JavaScript
microtasks and drive pending promises to completion.</p>
<p>Async ops are scheduled on the event loop and provide a way to run
Rust futures and resolve associated JavaScript promises. This is how
most of the I/O APIs like <code>Deno.readFile</code> are
implemented.</p>
<h3
id="jsruntimepoll_event_loop"><code>JsRuntime::poll_event_loop</code></h3>
<p>This drives Deno’s event loop. The code for
<code>poll_event_loop</code> is pretty self-explanatory if you’re
familiar with Rust futures and should make integration with V8’s
microtask queue clearer.</p>
<p>Let’s take a look at the things that happen: TODO.</p>
<h3 id="spawn_blocking"><code>spawn_blocking</code></h3>
<p><code>tokio::task::spawn_blocking</code> may be used when a CPU-bound
task if its too expensive or may end up blocking the main thread. The
task is spawned on Tokio’s threadpool. It’s used extensively in Deno for
WebCrypto computations and asynchronous file I/O.</p>
<p>Perf tip: Sometimes it’s better to avoid <code>spawn_blocking</code>
for CPU bound tasks when either the task is too small or the overhead of
spawning a new thread is too high.</p>
<p>Deadlocks: It is possible to deadlock the event loop when the
threadpool is saturated and tasks depend on each other. It is not common
but currently <code>Deno.flock</code> suffers from this issue.</p>
<h2 id="ops">Ops</h2>
<p>“ops” are the way Deno exposes Rust functionality to JavaScript. They
are the bridge between the JavaScript runtime and the Rust runtime.</p>
<p>Ops are analogous to syscalls in a operating system. They are used
for I/O, networking, file system access, etc.</p>
<p>Here’s a radial tree of all ops in Deno (there are about ~840 of
them):</p>
<p><img src="./assets/ops-radial.svg" /></p>
<h2 id="resources">Resources</h2>
<p>Resources are Rust-allocated objects that are referenced by
JavaScript code. Think of them as file descriptors. Resources may or may
not correspond to a real operating system file descriptor, they may
store arbitrary data for stateful operations or I/O handles.</p>
<p>There are 2 categories of resources in Deno.</p>
<h3 id="deno_coreresource"><code>deno_core::Resource</code></h3>
<p>JS integers that are allocated by the privileged side of Deno which
refer to various rust objects that need to be persisted between various
ops. For example, network sockets are resources.</p>
<p>A resource implements a <code>read</code>, <code>write</code> and
<code>close</code> method.</p>
<h3
id="deno_coregarbagecollected"><code>deno_core::GarbageCollected</code></h3>
<p>Typically resources must be explicitly closed by the user. However,
in some cases, it is desirable to have resources that are automatically
closed when they are no longer referenced by JavaScript code. This is
where <code>GarbageCollected</code> resources come in.</p>
<p><code>GarbageCollected</code> resources are automatically
de-allocated when the JavaScript object that references them is garbage
collected.</p>
<h3 id="cppgc">Cppgc</h3>
<p>Cppgc (Oilpan) is a tracing C++ garbage collector hosted through V8.
It is used to manage the lifetimes of <code>GarbageCollected</code>
resources. rusty_v8’s <code>cppgc</code> module provides a Rust
interface to Cppgc.</p>
<h2 id="permissions">Permissions</h2>
<p>Deno has a fine-grained permission system that allows users to
control what operations a script can perform. Permissions are requested
by the script and granted by the user.</p>
<p>Almost all of permission checks happen in the ops itself. An op that
does reads from a network resource is responsible for checking the
<code>net</code> permission.</p>
<blockquote>
<p>Tip: If an op creates a resource that will be required for future
ops, a one-time permission check during creation is usually
sufficient.</p>
</blockquote>
<p><code>deno_permission</code> crate is the home for all permission
related code that manages permission state, parsing allowlists, user
prompts, and checks.</p>
<p>There are 2 ways to do permission checks in an op:</p>
<ol type="1">
<li>Perform a direct check using <code>PermissionsContainer</code>
(recommended).</li>
</ol>
<p>Much like any other state, permission state are stored in the
<code>OpState</code> with type
<code>deno_permission::PermissionsContainer</code>.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>state</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span><span class="pp">borrow_mut::</span><span class="op">&lt;</span>PermissionsContainer<span class="op">&gt;</span>()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span>check_read(path<span class="op">,</span> <span class="st">&quot;Deno.readFile&quot;</span>)<span class="op">?;</span></span></code></pre></div>
<ol start="2" type="1">
<li>Use a custom trait that is passed on to the op when extension is
loaded (old way).</li>
</ol>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> NetPermission <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fn</span> allow_net(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> url<span class="op">:</span> <span class="op">&amp;</span><span class="pp">url::</span>Url) <span class="op">-&gt;</span> <span class="dt">bool</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>op<span class="at">]</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> fetch_url<span class="op">&lt;</span>P<span class="op">&gt;</span>(</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  state<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> OpState<span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  url<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>) <span class="kw">where</span> P<span class="op">:</span> NetPermission <span class="op">+</span> <span class="ot">&#39;static</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  state<span class="op">.</span><span class="pp">borrow_mut::</span><span class="op">&lt;</span>P<span class="op">&gt;</span>()<span class="op">.</span>allow_net(<span class="op">&amp;</span>url)<span class="op">?;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This may be desirable when you want to give other embedders the
flexibility to change the permission check logic.</p>
<h2 id="built-ins">Built-ins</h2>
<p>Front-facing built-in APIs in Deno are mostly written in JavaScript
and TypeScript. Some of them resort to calling Rust ops for part of
their functionality.</p>
<p>Code for built-ins is spread all over the codebase. It all comes
together and exposed to the user at
<code>runtime/js/90_deno_ns.js</code> and
<code>runtime/js/global_scope_window.js</code>. As the names suggest,
these are one of the last modules to be loaded and setup APIs for the
global <code>Deno</code> namespace and global objects.</p>
<p>Each extension crate usually numbers it’s built-in JS modules
prefixed with a incrementing numbers. The order of these numbers is
important as it determines the order in which the built-ins are
loaded.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ls ext/webgpu</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ex">00_init.js</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ex">01_webgpu.js</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="ex">02_surface.js</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="ex">...</span></span></code></pre></div>
<h2 id="node.js-compatibility">Node.js compatibility</h2>
<p>A lot of effort has been put into making Deno compatible with Node.js
runtime APIs. Located at <code>ext/node</code>, it is the largest
extension crate in Deno 2.</p>
<h3 id="node-api">Node API</h3>
<p>Node-API (previously known as N-API) is the C API for building native
addons for Node.js. It provides a stable ABI across different versions
of Node.js. Deno implements this API to provide compatibility with
Node.js native modules.</p>
<p>Symbols are defined using the <code>napi_sym</code> macro.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">napi_sym::</span>napi_sym<span class="at">]</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> napi_get_boolean(</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  env<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> Env<span class="op">,</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  value<span class="op">:</span> <span class="dt">bool</span><span class="op">,</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  result<span class="op">:</span> <span class="op">*</span><span class="kw">mut</span> napi_value<span class="op">,</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> _env<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Env <span class="op">=</span> env<span class="op">.</span>as_mut()<span class="op">.</span>ok_or(<span class="bu">Error</span><span class="pp">::</span>InvalidArg)<span class="op">?;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="cn">Ok</span>(())</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Symbol definition files are manually generated. It is a file
containing the symbols that need to be put into the executable’s dynamic
symbol table at link-time. This is done using <code>/DEF:</code> on
Windows, <code>-exported_symbol,_</code> on macOS and
<code>--export-dynamic-symbol=</code> on Linux.</p>
<blockquote>
<p>Note: On ancient glibc systems, the
<code>--export-dynamic-symbol</code> flag is not supported. In this
case, all symbols are exported by default. This results in a larger
binary size.</p>
</blockquote>
<h3 id="http">HTTP</h3>
<p><code>Deno.serve</code> is the primary HTTP API server in Deno. It is
a high-level API built on top of multiple ops that handle accepting
connections, reading requests, writing responses, etc.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>Deno<span class="op">.</span><span class="fu">serve</span>((request<span class="op">:</span> Request) <span class="kw">=&gt;</span> {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">new</span> <span class="fu">Response</span>(<span class="st">&quot;Hello World&quot;</span>)<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<h3 id="ffi">FFI</h3>
<p><code>Deno.dlopen</code> is the API for loading shared libraries and
calling symbols from them. It is heavily optimized for performance.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> sdl2 <span class="op">=</span> Deno<span class="op">.</span><span class="fu">dlopen</span>(<span class="st">&quot;libSDL2.so&quot;</span><span class="op">,</span> {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;SDL_Init&quot;</span><span class="op">:</span> {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;parameters&quot;</span><span class="op">:</span> [<span class="st">&quot;u32&quot;</span>]<span class="op">,</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;result&quot;</span><span class="op">:</span> <span class="st">&quot;i32&quot;</span><span class="op">,</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;SDL_GetPlatform&quot;</span><span class="op">:</span> {</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;parameters&quot;</span><span class="op">:</span> []<span class="op">,</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;result&quot;</span><span class="op">:</span> <span class="st">&quot;pointer&quot;</span><span class="op">,</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  }<span class="op">,</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (sdl2<span class="op">.</span><span class="at">symbols</span><span class="op">.</span><span class="fu">SDL_Init</span>(<span class="dv">0</span>) <span class="op">!=</span> <span class="dv">0</span>) {</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&quot;Failed to initialize SDL2&quot;</span>)<span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>It depends on <code>libffi</code> for conversions and
<code>dynasmrt</code> for generating trampoline to enable V8 fast API
calls. This is esentially a specialized JIT compiler that generates
efficient conversions from V8 fast call values to symbol parameters.</p>
<p><img src="./assets/turbocall-slide.png" /></p>
<p>I have a blog post on Turbocall JIT: <a
href="https://littledivy.com/turbocall.html"
class="uri">https://littledivy.com/turbocall.html</a></p>
<h3 id="websockets">WebSockets</h3>
<p>fastwebsockets is a fast RFC 6455 compliant WebSocket implementation
in Rust. It powers <code>new WebSocket</code> (client) and
<code>Deno.upgradeWebSocket</code> (server) APIs in Deno.</p>
</body>
</html>
